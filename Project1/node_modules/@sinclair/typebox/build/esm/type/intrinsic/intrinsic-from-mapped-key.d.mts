import type { SchemaOptions } from '@sinclair/typebox/build/esm/type/schema';
import type { TProperties } from '@sinclair/typebox/build/esm/type/object';
import { Assert } from '@sinclair/typebox/build/esm/type/helpers';
import { type TMappedResult, type TMappedKey } from '@sinclair/typebox/build/esm/type/mapped';
import { type TIntrinsic, type IntrinsicMode } from '@sinclair/typebox/build/esm/type/intrinsic/intrinsic.js';
import { type TLiteral, type TLiteralValue } from '@sinclair/typebox/build/esm/type/literal';
type TMappedIntrinsicPropertyKey<K extends PropertyKey, M extends IntrinsicMode> = {
    [_ in K]: TIntrinsic<TLiteral<Assert<K, TLiteralValue>>, M>;
};
type TMappedIntrinsicPropertyKeys<K extends PropertyKey[], M extends IntrinsicMode, Acc extends TProperties = {}> = (K extends [infer L extends PropertyKey, ...infer R extends PropertyKey[]] ? TMappedIntrinsicPropertyKeys<R, M, Acc & TMappedIntrinsicPropertyKey<L, M>> : Acc);
type TMappedIntrinsicProperties<K extends TMappedKey, M extends IntrinsicMode> = (TMappedIntrinsicPropertyKeys<K['keys'], M>);
export type TIntrinsicFromMappedKey<K extends TMappedKey, M extends IntrinsicMode, P extends TProperties = TMappedIntrinsicProperties<K, M>> = (TMappedResult<P>);
export declare function IntrinsicFromMappedKey<K extends TMappedKey, M extends IntrinsicMode, P extends TProperties = TMappedIntrinsicProperties<K, M>>(T: K, M: M, options: SchemaOptions): TMappedResult<P>;
export {};
