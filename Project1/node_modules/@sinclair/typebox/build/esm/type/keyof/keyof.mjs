import { CreateType } from '@sinclair/typebox/build/esm/type/create/type.mjs';
import { Literal } from '@sinclair/typebox/build/esm/type/literal/index.mjs';
import { Number } from '@sinclair/typebox/build/esm/type/number/index.mjs';
import { Computed } from '@sinclair/typebox/build/esm/type/computed/index.mjs';
import { Ref } from '@sinclair/typebox/build/esm/type/ref/index.mjs';
import { KeyOfPropertyKeys } from '@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs';
import { UnionEvaluated } from '@sinclair/typebox/build/esm/type/union/index.mjs';
import { KeyOfFromMappedResult } from '@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs';
// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
import { IsMappedResult, IsRef, IsComputed } from '@sinclair/typebox/build/esm/type/guard/kind.mjs';
// prettier-ignore
function FromComputed(target, parameters) {
    return Computed('KeyOf', [Computed(target, parameters)]);
}
// prettier-ignore
function FromRef($ref) {
    return Computed('KeyOf', [Ref($ref)]);
}
// prettier-ignore
function KeyOfFromType(type, options) {
    const propertyKeys = KeyOfPropertyKeys(type);
    const propertyKeyTypes = KeyOfPropertyKeysToRest(propertyKeys);
    const result = UnionEvaluated(propertyKeyTypes);
    return CreateType(result, options);
}
// prettier-ignore
export function KeyOfPropertyKeysToRest(propertyKeys) {
    return propertyKeys.map(L => L === '[number]' ? Number() : Literal(L));
}
/** `[Json]` Creates a KeyOf type */
export function KeyOf(type, options) {
    return (IsComputed(type) ? FromComputed(type.target, type.parameters) : IsRef(type) ? FromRef(type.$ref) : IsMappedResult(type) ? KeyOfFromMappedResult(type, options) : KeyOfFromType(type, options));
}
